require 'ncs_navigator/warehouse'

require 'erb'
require 'zip/zip'
require 'pathname'
require 'fileutils'
require 'forwardable'

module NcsNavigator::Warehouse
  ##
  # Generates VDR XML from a warehouse instance. This is the object
  # which implements the `emit-xml` tool in the `mdes-wh` command line
  # client.
  class XmlEmitter
    extend Forwardable

    ##
    # @return [Configuration] the warehouse configuration used by this
    #   emitter.
    attr_reader :configuration

    ##
    # @return [Array<Models::MdesModel>] the models whose data will be
    #   emitted. This is determined from the `:tables` option to
    #   {#initialize}.
    attr_reader :models

    ##
    # @private exposed for testing
    # @return [Array] the configuration objects related to each separate XML
    #   file emitted in one run.
    attr_reader :xml_files

    def_delegators :@configuration, :shell, :log

    HEADER_TEMPLATE = ERB.new(<<-XML_ERB)
<?xml version="1.0" encoding="UTF-8" ?>
<!--
  This document was generated by
  NCS Navigator MDES Warehouse #{NcsNavigator::Warehouse::VERSION}
-->
<ncs:recruitment_substudy_transmission_envelope
  xmlns:ncs="http://www.nationalchildrensstudy.gov"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  >
<ncs:transmission_header>
<sc_id><%= sc_id %></sc_id>
<psu_id><%= psu_id %></psu_id>
<specification_version><%= specification_version %></specification_version>
<is_snapshot>true</is_snapshot>
</ncs:transmission_header>
<ncs:transmission_tables>
XML_ERB

    FOOTER_TEMPLATE = <<-XML
</ncs:transmission_tables>
</ncs:recruitment_substudy_transmission_envelope>
XML

    ##
    # @param configuration [Configuration]
    # @return [Pathname] the default filename to use for a VDR XML
    #   submission. The format is `{county}-{YYYYMMDD}{-PII}.xml`.
    def self.default_filename(configuration, include_pii=false)
      psu_type = configuration.mdes.types.detect { |type| type.name =~ /^psu_cl/ }
      unless psu_type
        fail 'Cannot find the PSU code list. Please specify a filename manually.'
      end

      psu_id = configuration.navigator.psus.first.id
      psu_entry =  psu_type.code_list.detect { |cle| cle.value == psu_id }
      unless psu_entry
        fail "Cannot find PSU #{psu_id} in #{psu_type.name}. Please specify a filename manually."
      end

      Pathname.new '%s-%s%s.xml' % [
        psu_entry.label.split(',', 2).first.downcase.gsub(/\s*county\s*/, '').strip.gsub(' ', '_'),
        Time.now.iso8601.split('T').first.gsub('-', ''),
        include_pii ? '-PII' : ''
      ]
    end

    ##
    # Create a new {XmlEmitter}.
    #
    # @param [Configuration] config the configuration for the
    #   warehouse from which to emit records.
    # @param [Pathname,#to_s,nil] filename the filename to which the output
    #   will be written. If `nil`, the {.default_filename} is used.
    #
    # @option options [Fixnum] :block-size (5000) the maximum number
    #   of records to load into memory before writing them to the XML
    #   file. Reduce this to reduce the memory load of the emitter.
    #   Increasing it will probably not improve performance, even if
    #   you have sufficient memory to load more records.
    # @option options [Boolean] :include-pii (false) should PII
    #   variable values be included in the XML?
    # @option options [Array<#to_s>] :tables (all for current MDES
    #   version) the tables to include in the emitted XML.
    # @option options [Boolean] :zip (true) should a ZIP file be
    #   produced alongside the XML file?
    def initialize(config, filename, options={})
      @configuration = config
      @record_count = 0
      @block_size = options[:'block-size'] || 5000
      @zip = options.has_key?(:zip) ? options[:zip] : true

      @xml_files = determine_files_to_create(filename, options)


      @models =
        if options[:tables]
          options[:tables].collect { |t| t.to_s }.collect { |t|
            config.models_module.mdes_order.find { |model| model.mdes_table_name == t }
          }
        else
          config.models_module.mdes_order
        end
    end

    ##
    # Emit XML from the configured warehouse to {#filename}.
    #
    # @return [void]
    def emit_xml
      shell.say_line("Exporting to #{xml_files.collect(&:describe).join(', ')}")
      log.info("Beginning XML export to #{xml_files.collect(&:describe).join(', ')}")

      @start = Time.now
      xml_files.each { |xf| xf.write HEADER_TEMPLATE.result(binding) }
      models.each do |model|
        shell.clear_line_then_say('Writing XML for %33s' % model.mdes_table_name)
        write_all_xml_for_model(model)
      end
      xml_files.each { |xf| xf.write FOOTER_TEMPLATE }
      xml_files.each { |xf| xf.close }
      @end = Time.now

      msg = "%d records written in %d seconds (%.1f/sec).\n" % [@record_count, emit_time, emit_rate]
      shell.clear_line_then_say(msg)
      log.info(msg)

      xml_files.each { |xf| xf.zip_if_desired }
      log.info("XML export complete")
    end

    ##
    # @return [Pathname] the single file to which the XML will be emitted.
    #   Throws an exception if writing to multiple files.
    def filename
      if xml_files.size == 1
        xml_files.first.filename
      else
        fail "Emitting more than one file. Use `xml_files` to interrogate."
      end
    end

    ##
    # @return [Boolean] Will PII be included in the exported XML?
    #   Throws an exception if writing to multiple files.
    def include_pii?
      if xml_files.size == 1
        xml_files.first.include_pii?
      else
        fail "Emitting more than one file. Use `xml_files` to interrogate."
      end
    end

    ##
    # Will ZIP archive(s) be created along with the XML?
    #
    # @return [Boolean]
    def zip?
      @zip
    end

    private

    def determine_files_to_create(filename, options)
      if options[:'and-pii']
        # two files, one with and one without PII
        no_pii_filename = select_filename(filename, false)
        with_pii_filename = Pathname.new(no_pii_filename.to_s.sub(/^(.*?)(\..*)$/, '\1-PII\2'))
        [
          [false, no_pii_filename],
          [true, with_pii_filename]
        ].collect do |include_pii, fn|
          XmlFile.new(fn, include_pii, @zip, shell, log)
        end
      else
        # one file, PII determined by --include-pii
        include_pii = options[:'include-pii']
        actual_filename = select_filename(filename, include_pii)
        [
          XmlFile.new(actual_filename, include_pii, @zip, shell, log)
        ]
      end
    end

    def select_filename(filename, include_pii)
      case filename
      when Pathname
        filename
      when nil
        self.class.default_filename(configuration, include_pii)
      else
        Pathname.new(filename.to_s)
      end
    end

    def write_all_xml_for_model(model)
      shell.say(' %20s' % '[loading]')
      count = model.count
      offset = 0
      while offset < count
        shell.back_up_and_say(20, '%20s' % '[loading]')
        model.all(:limit => @block_size, :offset => offset).each do |instance|
          xml_files.each { |xf| xf.write_instance(instance) }
          @record_count += 1

          shell.back_up_and_say(20, '%5d (%5.1f/sec)' % [@record_count, emit_rate])
        end
        offset += @block_size
      end
    end

    def sc_id
      configuration.navigator.sc_id
    end

    def psu_id
      configuration.navigator.psus.first.id
    end

    def specification_version
      configuration.mdes.specification_version
    end

    def emit_time
      (@end || Time.now) - @start
    end

    def emit_rate
      @record_count / emit_time
    end

    ##
    # @private
    #
    # Encapsulated the data and operations related to one of the files produced
    # in a run. Consider "related to one of the files" in versus "related to
    # loading the records".
    class XmlFile < Struct.new(:filename, :include_pii, :zip, :shell, :log)
      alias :include_pii? :include_pii
      alias :zip? :zip

      def describe
        "#{filename} #{include_pii? ? 'with' : 'without'} PII"
      end

      def zip_filename
        @zip_filename ||= filename.to_s + '.zip'
      end

      def open
        @handle ||= filename.open('w')
      end
      alias :handle :open

      def write(s)
        handle.write(s)
      end

      def write_instance(instance)
        instance.write_mdes_xml(handle, :indent => 3, :margin => 1, :pii => include_pii?)
      end

      def close
        @handle && @handle.close
      end

      def zip_if_desired
        if zip?
          shell.say("Zipping to #{zip_filename}")
          log.info("Zipping to #{zip_filename}")
          Zip::ZipFile.open(zip_filename, Zip::ZipFile::CREATE) do |zf|
            zf.add(filename.basename, filename)
          end
          shell.clear_line_then_say("Zipped #{zip_filename}.")
        end
      end
    end
  end
end
