require 'ncs_navigator/warehouse'

require 'erb'
require 'zip/zip'
require 'pathname'
require 'fileutils'
require 'forwardable'

module NcsNavigator::Warehouse
  ##
  # Generates VDR XML from a warehouse instance. This is the object
  # which implements the `emit-xml` tool in the `mdes-wh` command line
  # client.
  class XmlEmitter
    extend Forwardable

    ##
    # @return [Configuration] the warehouse configuration used by this
    #   emitter.
    attr_reader :configuration

    ##
    # @return [Pathname] the file to which the XML will be emitted.
    attr_reader :filename

    ##
    # @return [Array<Models::MdesModel>] the models whose data will be
    #   emitted. This is determined from the `:tables` option to
    #   {#initialize}.
    attr_reader :models

    def_delegators :@configuration, :shell, :log

    HEADER_TEMPLATE = ERB.new(<<-XML_ERB)
<?xml version="1.0" encoding="UTF-8" ?>
<!--
  This document was generated by
  NCS Navigator MDES Warehouse #{NcsNavigator::Warehouse::VERSION}
-->
<ncs:recruitment_substudy_transmission_envelope
  xmlns:ncs="http://www.nationalchildrensstudy.gov"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  >
<ncs:transmission_header>
<sc_id><%= sc_id %></sc_id>
<psu_id><%= psu_id %></psu_id>
<specification_version><%= specification_version %></specification_version>
<is_snapshot>true</is_snapshot>
</ncs:transmission_header>
<ncs:transmission_tables>
XML_ERB

    FOOTER_TEMPLATE = <<-XML
</ncs:transmission_tables>
</ncs:recruitment_substudy_transmission_envelope>
XML

    ##
    # @param configuration [Configuration]
    # @return [Pathname] the default filename to use for a VDR XML
    #   submission. The format is `{county}-{YYYYMMDD}{-PII}.xml`.
    def self.default_filename(configuration, include_pii=false)
      psu_type = configuration.mdes.types.detect { |type| type.name =~ /^psu_cl/ }
      unless psu_type
        fail 'Cannot find the PSU code list. Please specify a filename manually.'
      end

      psu_id = configuration.navigator.psus.first.id
      psu_entry =  psu_type.code_list.detect { |cle| cle.value == psu_id }
      unless psu_entry
        fail "Cannot find PSU #{psu_id} in #{psu_type.name}. Please specify a filename manually."
      end

      Pathname.new '%s-%s%s.xml' % [
        psu_entry.label.split(',', 2).first.downcase.gsub(/\s*county\s*/, '').strip.gsub(' ', '_'),
        Time.now.iso8601.split('T').first.gsub('-', ''),
        include_pii ? '-PII' : ''
      ]
    end

    ##
    # Create a new {XmlEmitter}.
    #
    # @param [Configuration] config the configuration for the
    #   warehouse from which to emit records.
    # @param [Pathname,#to_s,nil] filename the filename to which the output
    #   will be written. If `nil`, the {.default_filename} is used.
    #
    # @option options [Fixnum] :block-size (5000) the maximum number
    #   of records to load into memory before writing them to the XML
    #   file. Reduce this to reduce the memory load of the emitter.
    #   Increasing it will probably not improve performance, even if
    #   you have sufficient memory to load more records.
    # @option options [Boolean] :include-pii (false) should PII
    #   variable values be included in the XML?
    # @option options [Array<#to_s>] :tables (all for current MDES
    #   version) the tables to include in the emitted XML.
    # @option options [Boolean] :zip (true) should a ZIP file be
    #   produced alongside the XML file?
    def initialize(config, filename, options={})
      @configuration = config
      @include_pii = options[:'include-pii']
      @filename = case filename
                  when Pathname
                    filename
                  when nil
                    self.class.default_filename(configuration, @include_pii)
                  else
                    Pathname.new(filename.to_s)
                  end
      @record_count = 0
      @block_size = options[:'block-size'] || 5000
      @zip = options.has_key?(:zip) ? options[:zip] : true
      @models =
        if options[:tables]
          options[:tables].collect { |t| t.to_s }.collect { |t|
            config.models_module.mdes_order.find { |model| model.mdes_table_name == t }
          }
        else
          config.models_module.mdes_order
        end
    end

    ##
    # Emit XML from the configured warehouse to {#filename}.
    #
    # @return [void]
    def emit_xml
      shell.say_line("Exporting to #{filename}")
      log.info("Beginning XML export to #{filename}")

      @start = Time.now
      filename.open('w') do |f|
        f.write HEADER_TEMPLATE.result(binding)

        models.each do |model|
          shell.clear_line_then_say('Writing XML for %33s' % model.mdes_table_name)

          write_all_xml_for_model(f, model)
        end

        f.write FOOTER_TEMPLATE
      end
      @end = Time.now
      msg = "%d records written in %d seconds (%.1f/sec).\n" % [@record_count, emit_time, emit_rate]
      shell.clear_line_then_say(msg)
      log.info(msg)

      if zip?
        shell.say_line("Zipping to #{zip_filename}")
        log.info("Zipping to #{zip_filename}")
        Zip::ZipFile.open(zip_filename, Zip::ZipFile::CREATE) do |zf|
          zf.add(filename.basename, filename)
        end
        log.info("XML export complete")
      end
    end

    ##
    # Will PII be included in the exported XML?
    #
    # @return [Boolean]
    def include_pii?
      @include_pii
    end

    ##
    # Will a ZIP archive be created along with the XML?
    #
    # @return [Boolean]
    def zip?
      @zip
    end

    ##
    # @return [Pathname] the filename for the ZIP archive of the XML,
    #   if any. Currently this is always {#filename} + '.zip'.
    # @see #zip?
    def zip_filename
      @zip_filename ||= filename.to_s + '.zip'
    end

    private

    def write_all_xml_for_model(f, model)
      shell.say(' %20s' % '[loading]')
      count = model.count
      offset = 0
      while offset < count
        shell.back_up_and_say(20, '%20s' % '[loading]')
        model.all(:limit => @block_size, :offset => offset).each do |instance|
          instance.write_mdes_xml(f, :indent => 3, :margin => 1, :pii => include_pii?)
          @record_count += 1

          shell.back_up_and_say(20, '%5d (%5.1f/sec)' % [@record_count, emit_rate])
        end
        offset += @block_size
      end
    end

    def sc_id
      configuration.navigator.sc_id
    end

    def psu_id
      configuration.navigator.psus.first.id
    end

    def specification_version
      configuration.mdes.specification_version
    end

    def emit_time
      (@end || Time.now) - @start
    end

    def emit_rate
      @record_count / emit_time
    end
  end
end
